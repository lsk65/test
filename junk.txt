
perl -ne 'next if /^\s*#/; if (!$found){ if (/\b(?i:KEY)\E\s+([^\s#]+)/){ $val=$1; $found=1 } } END{ exit($found && $val =~ /^(?:pattern1|pattern2)$/ ? 0 : 1) }' 

perl -ne 'next if /^\s*#/; exit 1 if /^\s*LogLevel\s+(?!INFO|VERBOSE)(\S+)/i'

key value -- all lines w/key checked -- RC=1 if ! found
perl -ne 'next if /^\s*#/; while (/\bLogLevel\s+([^\s#]+)/gi){ $v=$1; unless($v=~/^(?:INFO|VERBOSE)$/i){ exit 1 } $found=1 }'

perl -ne 'next if /^\s*#/; while (/\bLogLevel=([^\s#]+)/gi){ $v=$1; unless($v=~/^(?:on|auto)$/i){ exit 1 } $found=1 }' 

key value -- last line w/key checked only -- RC=1 if ! found
perl -ne 'next if /^\s*#/; while(/\bLogLevel\s+([^\s#]+)/gi){ $last=$1 } END{ exit($last && $last=~/^(?:INFO|VERBOSE)$/i ? 0 : 1) }'

key=value -- last line w/key checked only -- RC=1 if ! found
perl -ne 'next if /^\s*#/; while (/\bLogLevel\s*=\s*([^\s#]+)/gi) { $last=$1 } END{ exit($last && $last =~ /^(?:INFO|VERBOSE)$/i ? 0 : 1) }'

Now the above, except i need the first key value found
perl -ne 'next if /^\s*#/; if (!$found){ if (/\bKEY\s*=\s*([^\s#]+)/){ $val=$1; $found=1 } } END{ exit($found && $val =~ /^(?:pattern1|pattern2)$/ ? 0 : 1) }' file

perl -ne 'next if /^\s*#/; if (!$found){ if (/\bKEY\s*=\s*([^\s#]+)/){ $val=$1; $found=1 } } END{ exit($found && $val =~ /^(?:pattern1|pattern2)$/ ? 0 : 1) }' file

Use this variant to allow a variable number of spaces around the equals sign (already supported by \s*). Replace KEY, pattern1, pattern2, and file as needed.

perl -ne 'next if /^\s*#/; if (!$found){ if (/\bKEY\s+([^\s#]+)/){ $val=$1; $found=1 } } END{ exit($found && $val =~ /^(?:pattern1|pattern2)$/ ? 0 : 1) }' file

Replace KEY, pattern1, pattern2, and file as needed. This matches uncommented lines, finds the first occurrence of "KEYvalue" (one or more spaces), and exits 0 if that value equals pattern1 or pattern2 (case-sensitive), else exits 1


VALUE=$(sed -n 's/^TMOUT=\(.*\)$/\1/p' bashrc) && [ "$VALUE" != "900" ] && echo "TMOUT ($VALUE) is NOT equal to 900" || echo "TMOUT is 900 or not found"

VALUE=$(sed -n '/^[[:space:]]*#/!s/.*TMOUT=\([0-9]*\).*/\1/p' bashrc); [ "$VALUE" != "900" ]

[ -n "${TMOUT+x}" ] && readonly TMOUT || readonly TMOUT=900; export TMOUT

awk -F'[ =;]' '/key=/ {for (i=1; i<=NF; i++) if ($i=="key") print $(i+1)}' file

awk -F'[ =;]' '/key=[^;]*/ {for (i=1; i<=NF; i++) if ($i=="key") print $(i+1)}' file

awk -F'[ ;]' '/key=[0-9]+;/{split($0, a, "key="); print a[2]}' filename | awk -F';' '{print $1}' file

awk -F'[ =;]' '/key=[0-9]+;/{for (i=1; i<=NF; i++) if ($i=="key") {print $(i+1); break}}' file

awk -F'[ =;]' '/TMOUT=[0-9]+;/{for (i=1; i<=NF; i++) if ($i=="TMOUT") print $(i+1)}' file

awk -F'\\s+|;' '/TMOUT=[0-9]+/ {for (i=1; i<=NF; i++) if ($i ~ /^TMOUT=/) print $i}' file

awk -F'[ =;]' '/TMOUT=[0-9]+/ {for (i=1; i<=NF; i++) if ($i=="TMOUT") print $(i+1)}' file

awk -F'[:,;]' '/readonly TMOUT=[0-9]+/ {split($2, a, "="); print a[2]}' file

# finally worked ! TMOUT=900 and printed the 900 !
awk -F'[:,;]' '/TMOUT=[0-9]+/ {split($1, a, "="); print a[2]}' file 

awk -F'[:,;]' '/readonly TMOUT=[0-9]+/ {split($2, a, "="); if (a[2] != "900") exit 1; exit 0}' file

if awk -F'[:,;]' '/readonly TMOUT=[0-9]+/ {split($2, a, "="); if (a[2] != "900") exit 1; exit 0}' filename; then 
    echo "TMOUT is 900"
else 
    echo "TMOUT is not 900"
fi

if awk -F'[:,;]' '/readonly TMOUT=[0-9]+/{split($2,a,"="); exit (a[2] != "900")} filename; then 
    echo "TMOUT is 900"; 
else 
    echo "TMOUT is not 900"; 
fi

if awk -F'[ =;]' '/readonly TMOUT=/ {if ($2 != "900") exit 1; exit 0}' file

if awk -F'[ =;]' '/readonly TMOUT=/ {split($3, a, "="); if (a[2] != "900") exit 1} END {if (NR == 0) exit 1}'; then


# THIS WORKS!
#
if awk -v key="TMOUT" 'BEGIN { rc = 1 }; { if \
(match($0, "(^|[[:space:][:punct:]])" key "[[:space:]]*=[[:space:]]*\"?([0-9]+)\"?", m)) \
{ if (m[2] != 900) { rc = 0; exit rc } else { rc = 1; exit rc }}} END { exit rc }' "${f}"; then
   echo -e "ailed 5.6.3" | tee -a $CISLOG
fi
#
#


